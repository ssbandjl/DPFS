git repo: https://github.com/ssbandjl/DPFS
update submodule: git submodule update --init --recursive


DPFS Arch:

dpfs_kv/main.cpp -> main
    dpfs_fuse_main
        struct dpfs_fuse *fuse = dpfs_fuse_new(&ops, conf_path, vnfs, NULL, NULL)
            fuse_ll_map(f_ll)
            hal_params.ops.request_handler = fuse_handle_req;
                fuse_handler_t h = fuse_ll->fuse_handlers[in_hdr->opcode]
            hal_params.ops.register_device = register_dpfs_device;
                ndevices++
            hal_params.ops.unregister_device = unregister_dpfs_device;
            struct dpfs_hal *hal = dpfs_hal_new(&hal_params, false)
        dpfs_fuse_loop


HAL -> dpfs_hal/src/snap.c
dpfs_hal_new
    struct dpfs_hal *hal = calloc(1, sizeof(struct dpfs_hal))
    nvme_init_logger
    mlnx_snap_pci_manager_init
    dpfs_hal_init_dev(hal, dev, device_id, emu_manager.u.s, pf.u.i, tag.u.s, qd.u.i)
        param.dev_type = "virtiofs_emu"
        param.virtiofs_emu_handle_req = dpfs_hal_handle_req
            hal->ops.request_handler(hal->user_data, in_iov, in_iovcnt, out_iov, out_iovcnt, done_ctx, dev->device_id)
        struct virtio_fs_ctrl_init_attr param
        struct virtio_fs_ctrl *snap_ctrl = virtio_fs_ctrl_init(&param)
        hal->ops.register_device(hal->user_data, device_id)
    pthread_create(&hal->mock_thread, NULL, dpfs_hal_mock_thread, hal)
        virtio_fs_ctrl_progress_all_io
        virtio_fs_ctrl_progress
        virtio_fs_ctrl_suspend



introduce:
DPFS æ¡†æž¶å…è®¸äº‘å’Œæ•°æ®ä¸­å¿ƒè¿è¥å•†ä½¿ç”¨ DPU å¸è½½ä¸ºç§Ÿæˆ·æä¾›è™šæ‹ŸåŒ–æ–‡ä»¶ç³»ç»ŸæœåŠ¡ã€‚å€ŸåŠ© DPFSï¼Œå®Œæ•´çš„æ–‡ä»¶ç³»ç»Ÿå®žçŽ°å¯åœ¨ DPU çš„ CPU å¤åˆä½“ä¸Šè¿è¡Œã€‚ç§Ÿæˆ·é€šè¿‡virtio-fsDPU åœ¨ PCIe ä¸Šå…¬å¼€çš„è®¾å¤‡ï¼ˆé€šè¿‡ SR-IOV å®žçŽ°å¤šç§Ÿæˆ·ï¼‰ä½¿ç”¨æ–‡ä»¶ç³»ç»Ÿã€‚DPFS æä¾›ç¡¬ä»¶æŠ½è±¡å±‚ã€FUSE API å®žçŽ°å’Œå¤šä¸ªæ–‡ä»¶ç³»ç»Ÿå®žçŽ°ã€‚, è­¦å‘Šï¼šDPFS ç›®å‰æ˜¯ä¸€ä¸ªç ”ç©¶é¡¹ç›®ï¼Œå› æ­¤å…¶ä»£ç å°šæœªç»è¿‡å®žæˆ˜æµ‹è¯•ï¼Œä¹Ÿä¸æ˜¯å¾ˆå¹²å‡€ã€‚è¯·è‡ªè¡Œå†³å®šæ˜¯å¦ä½¿ç”¨

åœ¨ BlueField-2ï¼ˆç›®å‰ä»…æ”¯æŒ DPUï¼‰ä¸Šè¿è¡Œæ‰€éœ€çš„ Nvidia SNAP åº“æ˜¯é—­æºçš„ï¼Œéœ€è¦è¡¥ä¸æ‰èƒ½å¯ç”¨å¼‚æ­¥è¯·æ±‚å®Œæˆ

è”ç³»æ–¹å¼å’Œè‡´è°¢
ðŸ‡¨ðŸ‡­ IBM è‹é»Žä¸–ç ”ç©¶ä¸­å¿ƒæ··åˆäº‘/åŸºç¡€è®¾æ–½è½¯ä»¶å°ç»„
ðŸ‡³ðŸ‡± é˜¿å§†æ–¯ç‰¹ä¸¹è‡ªç”±å¤§å­¦çš„ StoNet ç ”ç©¶





fuse_ll_map
    fuse_ll->fuse_handlers[FUSE_INIT] = fuse_ll_init;
    fuse_ll->fuse_handlers[FUSE_DESTROY] = fuse_ll_destroy;
    fuse_ll->fuse_handlers[FUSE_GETATTR] = fuse_ll_getattr;
    fuse_ll->fuse_handlers[FUSE_LOOKUP] = fuse_ll_lookup;
    fuse_ll->fuse_handlers[FUSE_SETATTR] = fuse_ll_setattr;
    fuse_ll->fuse_handlers[FUSE_OPENDIR] = fuse_ll_opendir;
    fuse_ll->fuse_handlers[FUSE_RELEASEDIR] = fuse_ll_releasedir;
    fuse_ll->fuse_handlers[FUSE_READDIR] = fuse_ll_readdir;
    fuse_ll->fuse_handlers[FUSE_READDIRPLUS] = fuse_ll_readdirplus;
    fuse_ll->fuse_handlers[FUSE_OPEN] = fuse_ll_open;
    fuse_ll->fuse_handlers[FUSE_RELEASE] = fuse_ll_release;
    //// We don't impl FUSE_FLUSH. The only use would be to return w
    //// but that's of no use with a remote file system
    fuse_ll->fuse_handlers[FUSE_FSYNC] = fuse_ll_fsync;
    fuse_ll->fuse_handlers[FUSE_FSYNCDIR] = fuse_ll_fsyncdir;
    fuse_ll->fuse_handlers[FUSE_CREATE] = fuse_ll_create;
    fuse_ll->fuse_handlers[FUSE_RMDIR] = fuse_ll_rmdir;
    fuse_ll->fuse_handlers[FUSE_FORGET] = fuse_ll_forget;
    fuse_ll->fuse_handlers[FUSE_BATCH_FORGET] = fuse_ll_batch_forget
    fuse_ll->fuse_handlers[FUSE_RENAME] = fuse_ll_rename;
    fuse_ll->fuse_handlers[FUSE_RENAME2] = fuse_ll_rename2;
    fuse_ll->fuse_handlers[FUSE_READ] = fuse_ll_read;
    fuse_ll->fuse_handlers[FUSE_WRITE] = fuse_ll_write;
    fuse_ll->fuse_handlers[FUSE_MKNOD] = fuse_ll_mknod;
    fuse_ll->fuse_handlers[FUSE_MKDIR] = fuse_ll_mkdir;
    fuse_ll->fuse_handlers[FUSE_SYMLINK] = fuse_ll_symlink;
    fuse_ll->fuse_handlers[FUSE_STATFS] = fuse_ll_statfs;
    fuse_ll->fuse_handlers[FUSE_UNLINK] = fuse_ll_unlink;
    fuse_ll->fuse_handlers[FUSE_READLINK] = fuse_ll_readlink;
    fuse_ll->fuse_handlers[FUSE_FLUSH] = fuse_ll_flush;
    fuse_ll->fuse_handlers[FUSE_SETLKW] = fuse_ll_setlkw;
    fuse_ll->fuse_handlers[FUSE_SETLK] = fuse_ll_setlk;
    fuse_ll->fuse_handlers[FUSE_FALLOCATE] = fuse_ll_fallocate;



dpfs_template/main.c -> main -> è¿™æ˜¯ä¸€ä¸ªå…³äºŽå¦‚ä½•ä½¿ç”¨ DPFS å®žçŽ° virtio-fs è®¾å¤‡çš„ç¤ºä¾‹æ¨¡æ¿ï¼Œæ— éœ€ä½¿ç”¨ DPFS-FUSE å±‚ã€‚è¿™æ„å‘³ç€åŽç«¯å¿…é¡»è‡ªè¡Œå®žçŽ°å’Œè§£é‡Š FUSE ABI
    hal_params.ops.request_handler = fuse_handler
    struct dpfs_hal *hal = dpfs_hal_new(&hal_params, false)
    dpfs_hal_loop(hal)
        start_low_latency
            open("/dev/cpu_dma_latency", O_WRONLY)
        dpfs_hal_loop_static
            pthread_create(&hal->mock_thread, NULL, dpfs_hal_mock_thread, hal)
            pthread_create(&tdatas[i].thread, NULL, dpfs_hal_loop_static_thread, &tdatas[i])
                sched_setaffinity(gettid(), sizeof(loop_cpu), &loop_cpu)
                all_devices_suspended
                    virtio_fs_ctrl_is_suspended(hal->devices[i].snap_ctrl)
                dpfs_hal_poll_device(&hal->devices[i])
                    virtio_fs_ctrl_progress_all_io(dev->snap_ctrl)
                    virtio_fs_ctrl_progress(dev->snap_ctrl)
        stop_low_latency
            close(pm_qos_fd)

create_session
    create_session_cb
        lookup_true_rootfh
            lookup_true_rootfh_cb


eRPC
extern/eRPC-arm/README.md
./scripts/do.sh 0 0
scripts/example_autorun_app_file
scripts/run-all.sh
extern/eRPC-arm/hello_world/server.cc
    nexus.register_req_func(kReqType, req_handler)
        req_handler
            resize_msg_buffer
    rpc->run_event_loop(100000)
extern/eRPC-arm/hello_world/client.cc
    create_session
    alloc_msg_buffer_or_die
    enqueue_request
    run_event_loop





enqueue_request
    void Rpc<TTr>::kick_req_st
        enqueue_pkt_tx_burst_st
            do_tx_burst_st
                transport_->tx_burst(tx_burst_arr_, tx_batch_i_) -> void IBTransport::tx_burst
                    int ret = ibv_post_send(qp, &send_wr[0], &bad_wr)
                    

dpfs_rvfs: remote virt fs
dpfs_rvfs_dpuï¼Œæ­¤äºŒè¿›åˆ¶æ–‡ä»¶ä½¿ç”¨ dpfs_hal virtio-fs æŠ½è±¡å±‚ï¼Œå¹¶ä½¿ç”¨ RVFS äºŒè¿›åˆ¶æ ¼å¼çš„ eRPC é€šè¿‡ç½‘ç»œç›´æŽ¥å‘è¿œç¨‹æœåŠ¡å™¨å‘é€è¯·æ±‚ã€‚RVFS äºŒè¿›åˆ¶æ ¼å¼æ­¤æ ¼å¼å°†æè¿°è¿œç¨‹è™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿåè®®ï¼Œå³é€šè¿‡ RPC ç›´æŽ¥é€šè¿‡ç½‘ç»œçš„ virtio-fsã€‚æ ¼å¼å¯èƒ½ä¼šæ›´æ”¹å’Œæ­£åœ¨è¿›è¡Œä¸­ã€‚æ­¤åè®®ä¸ç›´æŽ¥å‘æ¶ˆè´¹â€‹â€‹è€…/äº‘ç§Ÿæˆ·å…¬å¼€ï¼Œæ¶ˆè´¹è€…/äº‘ç§Ÿæˆ·ä½¿ç”¨ virtio-fsã€‚å› æ­¤ï¼Œæˆ‘ä»¬ä¸ä¼šåœ¨ç½‘ç»œæ ¼å¼ä¸­æž„å»ºä»»ä½•å‘åŽå…¼å®¹æ€§
int main(int argc, char **argv)
    hal_params.ops.request_handler = fuse_handler
        resize_msg_buffer
        enqueue_request
    hal_params.ops.register_device = register_dpfs_device





dpfs_nfs/main.c -> Implemented new HAL multi-tenancy threading in NFS -> https://github.com/ssbandjl/DPFS/commit/4d39510f51c8cffe26ae7cfe43d0f247b081d6b4
    dpfs_nfs_main(server.u.s, export.u.s, 0.0, cq_polling.u.b, conf_path)
        inode_table_init
        struct fuse_ll_operations ops
        dpfs_nfs_assign_ops(&ops)
            ops->init = init;
            ops->lookup = lookup;
            ops->getattr = getattr;
            // NFS accepts the NFS:fh
            // its parameter to the d
            ops->opendir = NULL;
            ops->open = vopen;
            ops->read = vread;
            ops->write = vwrite;
                struct write_cb_data *cb_data = mpool_alloc
                cb_data->slotid = vnfs4_op_sequence(&op[0], conn, false)
                struct inode *i = vnfs4_op_putfh_open
                    struct inode *i = inode_table_get(vnfs->inodes, nodeid)
                        size_t hash = inode_table_hash(t, fileid)
                            return fileid % t->size
                rpc_nfs4_compound_async2 vwrite_cb -> LIBNFS is a client library for accessing NFS shares over a network
                    rpc_allocate_pdu2
                        rpc_add_iovector
                    rpc_queue_pdu(rpc, pdu)
                        if (rpc->is_broadcast)
                            sendto
                        if (writev(rpc->fd, &iov[1], niov - 1)
                        rpc_hash_xid
                        rpc_enqueue(&rpc->waitpdu[hash], pdu)
                            q->tail = pdu
            ops->fsync = vfsync;
            ops->release = release;
            // NFS only does fsync(ak
            ops->fsyncdir = NULL;
            // The concept of flushin
            ops->flush = NULL;
            //ops->setattr = (typeof(
            ops->statfs = statfs;
            ops->destroy = destroy;
        dpfs_fuse_new(&ops, conf_path, vnfs, NULL, NULL)
        vnfs->nthreads = dpfs_fuse_nthreads(fuse)
        mpool_init(&vnfs->p[i], sizeof(struct cb_data), 256)
            *p = calloc(1, sizeof(struct mpool))
            (*p)->buffer = malloc
            ck_ring_init(&(*p)->ring, chunks) -> åˆå§‹åŒ–ä¸€ä¸ªç”± ring æŒ‡å‘çš„æœ‰ç•Œ FIFO ç¼“å†²åŒºï¼Œç”¨äºŽå­˜å‚¨æœ€å¤š size ä¸ªæŒ‡é’ˆã€‚size å‚æ•°å¿…é¡»æ˜¯å¤§äºŽæˆ–ç­‰äºŽ 4 çš„ 2 çš„å¹‚
            void *e = malloc(chunk_size)
        vnfs->conns = calloc(vnfs->nthreads
        vnfs_init_connections(vnfs)
            struct nfs_context *nfs = nfs_init_context()
                nfs->rpc = rpc_init_context()
                rpc_current_time
            nfs_set_version(nfs, NFS_V4)
            nfs_get_rpc_context
            nfs_mount(nfs, vnfs->server, vnfs->export)
                nfs_mount_async(nfs, server, export, mount_cb, &cb_data)
                    nfs3_mount_async
                    or nfs4_mount_async
                        rpc_connect_port_async
                            rpc_connect_port_internal
                                rpc_connect_async rpc_connect_program_4_cb
                                    rpc_connect_sockaddr_async
                                        connect
                                    rpc_connect_program_4_cb
                                        rpc_null_async rpc_connect_program_5_cb
                                            rpc_allocate_pdu
                                                rpc_allocate_pdu2
                                            rpc_queue_pdu
                                            rpc_connect_program_5_cb
                                                data->cb
                wait_for_nfs_reply
                    nfs_service
                        rpc_service(nfs->rpc, revents)
            nfs_set_poll_timeout
            nfs_mt_service_thread_start
            exchangeid
        dpfs_fuse_loop(fuse) -> dpfs_hal_loop
        dpfs_fuse_destroy(fuse)
        inode_table_destroy(vnfs->inodes)